/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. D:/cygwin/home/djiao/workspace/cdk-mirror/src/org/openscience/cdk/smiles/smarts/parser\SMARTSParser.jj */
/*@egen*/options {
	STATIC=false;
	FORCE_LA_CHECK=true;
	USER_CHAR_STREAM = false;
    UNICODE_INPUT = false;
    IGNORE_CASE = false;                                                                 
}

PARSER_BEGIN(SMARTSParser)

package org.openscience.cdk.smiles.smarts.parser;

import java.io.StringReader;

import org.openscience.cdk.exception.CDKException;
import org.openscience.cdk.isomorphism.matchers.QueryAtomContainer;
import org.openscience.cdk.smiles.smarts.parser.visitor.SmartsQueryVisitor;
import org.openscience.cdk.tools.LoggingTool;

public class SMARTSParser/*@bgen(jjtree)*/implements SMARTSParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTSMARTSParserState jjtree = new JJTSMARTSParserState();

/*@egen*/

	public static QueryAtomContainer parse(String stringToParse) throws CDKException {
        QueryAtomContainer container = null;
        StringReader stringReader = new StringReader(stringToParse);
        try {
            SMARTSParser parser = new SMARTSParser(stringReader);
            ASTStart start = parser.Start();
            SmartsQueryVisitor visitor = new SmartsQueryVisitor();
            container = (QueryAtomContainer)start.jjtAccept(visitor, null);
        } catch (ParseException exception) {
            throw new CDKException("The string " + stringToParse + " is not a valid" +
              " SMARTS string: " + exception.getMessage(), exception);
        }
        return container;	
	} 
}

PARSER_END(SMARTSParser)

<*> TOKEN:
{
    <#_WS: ( " " | "\t" | "\n" | "\r" ) >
}

<DEFAULT> TOKEN:
{
    // Logical Operators
    <L_AND : ";" >
    |
    <H_AND : "&" >
    |
    <OR    : "," >
    |
    <NOT   : "!" >
    |
    // Bond
    <   S_BOND : "-" >  // single bond 
    |
    <UP_S_BOND : "/" >  // directional single bond "up"
    |
    <DN_S_BOND : "\\" > // directional sinble bond "down"
    |
    <UP_OR_UNSPECIFIED_S_BOND : "/?" > 
    |
    <DN_OR_UNSPECIFIED_S_BOND : "\\?" >
    |
    <   D_BOND : "=" >  // double bond
    |
    <   T_BOND : "#" >  // triple bond
    |
    <   AR_BOND : ":" >  // aromatic bond
    |
    < ANY_BOND : "~" >  // any bond
    |
    <   R_BOND : "@" >  // any ring bond
    |
    // Elements
        <  c: "c" >
    |   <  n: "n" >
    |   <  o: "o" >
    |   <  H: "H" >
    |   < HE: "He" >
    |   < LI: "Li" >
    |   < BE: "Be" >
    |   <  B: "B" >
    |   <  C: "C" >
    |   <  N: "N" >
    |   <  O: "O" >
    |   <  F: "F" >
    |   < NE: "Ne" >
    |   < NA: "Na" >
    |   < MG: "Mg" >
    |	< AL: "Al" >
    |	< SI: "Si" >
    |   <  P: "P" >
    |   <  S: "S" >
    |	< CL: "Cl" >
    |	< AR: "Ar" >
    |   <  K: "K" >
    |   < CA: "Ca" >
    |   < SC: "Sc" >
    |   < TI: "Ti" >
    |   <  V: "V" >
    |   < CR: "Cr" >
    |   < MN: "Mn" >
    |   < FE: "Fe" >
    |   < CO: "Co" >
    |   < NI: "Ni" >
    |   < CU: "Cu" >
    |   < ZN: "Zn" >
    |   < GA: "Ga" >
    |   < GE: "Ge" >
    |   < AS: "As" >
    |   < SE: "Se" >
    |   < BR: "Br" >
    |   < KR: "Kr" >
    |   < RB: "Rb" >
    |   < SR: "Sr" >
    |   <  Y: "Y" >
    |   < ZR: "Zr" >
    |   < NB: "Nb" >
    |   < MO: "Mo" >
    |   < TC: "Tc" >
    |   < RU: "Ru" >
    |   < RH: "Rh" >
    |   < PD: "Pd" >
    |   < AG: "Ag" >
    |   < CD: "Cd" >
    |   < IN: "In" >
    |   < SN: "Sn" >
    |   < SB: "Sb" >
    |   < TE: "Te" >
    |   <  I: "I" >
    |   < XE: "Xe" >
    |   < CS: "Cs" >
    |   < BA: "Ba" >
    |   < LA: "La" >
    |   < HF: "Hf" >
    |   < TA: "Ta" >
    |   <  W: "W" >
    |   < RE: "Re" >
    |   < OS: "Os" >
    |   < IR: "Ir" >
    |   < PT: "Pt" >
    |   < AU: "Au" >
    |   < HG: "Hg" >
    |   < TL: "Tl" >
    |   < PB: "Pb" >
    |   < BI: "Bi" >
    |   < PO: "Po" >
    |   < AT: "At" >
    |   < RN: "Rn" >
    |   < FR: "Fr" >
    |   < RA: "Ra" >
    |   < AC: "Ac" >
    |   < TH: "Th" >
    |   < PA: "Pa" >
    |   <  U: "U" >
    // Atomic Primitives
    |   < WILDCARD: "*" >
    |
    <h : "h" >
    |
    <a : "a" >
    |
    <A : "A" >
    |
    <D : "D" >
    |
    <R : "R" >
    |
    <r : "r" >
    |
    <v : "v" >
    |
    <X : "X" >
    |
    <x : "x" >
    |
    <DOLLAR : "$" >
    |
    <L_PAREN : "(" >
    | 
    <R_PAREN : ")" >
    |
    <L_BRACKET : "[" >
    |
    <R_BRACKET : "]" >
    |
    <NUMBER: (["0"-"9"])+ >
}

/**
 *                     Start ::= ReactionExpression
 *        ReactionExpression ::= GroupExpression (">>" GroupExpression)? |
 *                               ">" GroupExpression ">" | ">>" GroupExpression
 *           GroupExpression ::= "(" SmartsExpresion ")" ( "." "(" SmartsExpression ")" )*
 *          SmartsExpression ::= ( LogicalExpression | ExplicitAtomExpression ) 
 *                               ( "<" [Bond] SmartsExpression ">" )* ( [Bond] SmartsExpression )?
 *                      Bond ::= LowAndBond
 *                LowAndBond ::= OrBond [ ";" AndBond ]
 *                    OrBond ::= ExplicitHighAndBond [ "," OrBond ]
 *       ExplicitHighAndBond ::= ImplicitHighAndBond [ "&" ExplicitHighAndBond ]
 *       ImplicitHighAndBond ::= NotBond [ ImplicitHighAndBond ]
 *                   NotBond ::= [ "!" ] SimpleBond
 *                SimpleBond ::= "/" | "\\" | "/?" | "\\?" | "=" | "#" | "~" | "@"
 *    ExplicitAtomExpression ::= ( "B" | "C" | "N" | "O" | "P" | "S" | "F" | "CL" | "BR" | "I" 
 *                               | "c" | "o" | "n" | "*" | "A" | "a" ) [ Number ]
 *         LogicalExpression ::= "[" LowAndExpression "]" [ Number ]
 *          LowAndExpression ::= OrExpression ( ";" LowAndExpression )?
 *              OrExpression ::= ExplicitHighAndExpression ( "," OrExpression ) ?
 * ExplicitHighAndExpression ::= ImplicitHighAndExpression ( "&" ExplicitHighAndExpression )?
 * ImplicitHighAndExpression ::= NotExpression ( ImplicitHighAndExpression ) ?
 *             NotExpression ::= "!" ( PrimitiveAtomExpression | RecursiveSmartsExpression )
 * RecursiveSmartsExpression ::= "$" "(" SmartsExpression ")"
 *   PrimitiveAtomExpression ::= NonHydrogenElement | "*" | "A" | "a" | "D" Number? | "H" Number? | "h" Number? 
 *                               | "R" Number? | "r" Number? | "v" Number? | "X" Number? | "x" Number? 
 *                               | ("+" | "-") Number? | "#" Number? | "@" | "@@" | Number
 *                    Number ::= ( "0"-"9" )+
 *         onHydrogenElement ::= ( "HE" | "LI" | "BE" | "NE" | "NA" | "MG" | "AL" | "SI" | "AR" | "CA" | "SC" |
 *                               "TI" | "CR" | "MN" | "FE" | "CO" | "NI" | "CU" | "ZN" | "GA" | "GE" | "AS" |
 *                               "SE" | "BR" | "KR" | "RB" | "SR" | "ZR" | "NB" | "MO" | "TC" | "RU" | "RH" |
 *                               "PD" | "AG" | "CD" | "IN" | "SN" | "SB" | "TE" | "XE" | "CS" | "BA" | "LA" |
 *                               "HF" | "TA" | "RE" | "OS" | "IR" | "PT" | "AU" | "HG" | "TL" | "PB" | "BI" |
 *                               "PO" | "AT" | "RN" | "FR" | "RA" | "AC" | "TH" | "PA" |
 *                               "B" | "C" | "N" | "O" | "F" | "P" | "S" | "K" | "V" | "Y" | "I" | "U" |
 *                               "c" | "o" | "n" ) [ NUMBER ]
 */

ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    ReactionExpression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ReactionExpression()           : {/*@bgen(jjtree) Reaction */
  ASTReaction jjtn000 = new ASTReaction(JJTREACTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Reaction */
    try {
/*@egen*/
    GroupExpression() ( ">>" [GroupExpression()] )?
    |
    ">" GroupExpression() ">"
    |
    ">>" GroupExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GroupExpression()        : {/*@bgen(jjtree) Group */
  ASTGroup jjtn000 = new ASTGroup(JJTGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Group */
    try {
/*@egen*/
    [<L_PAREN>] SmartsExpression() [<R_PAREN>] ( "." [<L_PAREN>] SmartsExpression() [<R_PAREN>] ) */*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

void SmartsExpression()         : {/*@bgen(jjtree) Smarts */
  ASTSmarts jjtn000 = new ASTSmarts(JJTSMARTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Smarts */
    try {
/*@egen*/
    ( LogicalExpression() | ExplicitAtomExpression() ) 
    ( <L_PAREN> [ Bond() ] SmartsExpression() <R_PAREN> ) * 
    ( [ Bond() ] SmartsExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Bond()       : {/*@bgen(jjtree) Bond */
  ASTBond jjtn000 = new ASTBond(JJTBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bond */
    try {
/*@egen*/
    LowAndBond()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void LowAndBond()             : {/*@bgen(jjtree) LowAndBond */
  ASTLowAndBond jjtn000 = new ASTLowAndBond(JJTLOWANDBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LowAndBond */
    try {
/*@egen*/
    OrBond() ( <L_AND> LowAndBond() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void OrBond()         : {/*@bgen(jjtree) OrBond */
  ASTOrBond jjtn000 = new ASTOrBond(JJTORBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrBond */
    try {
/*@egen*/
    ExplicitHighAndBond() ( <OR> OrBond() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExplicitHighAndBond()                      : {/*@bgen(jjtree) ExplicitHighAndBond */
  ASTExplicitHighAndBond jjtn000 = new ASTExplicitHighAndBond(JJTEXPLICITHIGHANDBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExplicitHighAndBond */
    try {
/*@egen*/
    ImplicitHighAndBond() ( <H_AND> ExplicitHighAndBond() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImplicitHighAndBond()                      : {/*@bgen(jjtree) ImplicitHighAndBond */
  ASTImplicitHighAndBond jjtn000 = new ASTImplicitHighAndBond(JJTIMPLICITHIGHANDBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImplicitHighAndBond */
    try {
/*@egen*/
    NotBond() ( ImplicitHighAndBond() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NotBond()          : {/*@bgen(jjtree) NotBond */
  ASTNotBond jjtn000 = new ASTNotBond(JJTNOTBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NotBond */
    try {
/*@egen*/
    [ <NOT> { jjtn000.setType(SMARTSParserConstants.NOT); } ] SimpleBond()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}
void SimpleBond()             : {/*@bgen(jjtree) SimpleBond */
  ASTSimpleBond jjtn000 = new ASTSimpleBond(JJTSIMPLEBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SimpleBond */
    try {
/*@egen*/
    (
        LOOKAHEAD(2)
        <S_BOND> 
        | 
        <UP_S_BOND> // TODO: Need API
        | 
        <DN_S_BOND> // TODO: Need API
        | 
        <UP_OR_UNSPECIFIED_S_BOND> // TODO: Need API
        | 
        <DN_OR_UNSPECIFIED_S_BOND> // TODO: Need API
        | 
        <D_BOND> 
        | 
        <T_BOND> 
        | 
        <AR_BOND> 
        | 
        <ANY_BOND> 
        | 
        <R_BOND> // TODO: Need API
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setBondType(token.kind);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExplicitAtomExpression()               : {/*@bgen(jjtree) ExplicitAtom */
  ASTExplicitAtom jjtn000 = new ASTExplicitAtom(JJTEXPLICITATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExplicitAtom */
    try {
/*@egen*/
    ( <B> | <C> | <N> | <O> | <P> | <S> | <F> | <CL> | <BR> | <I> | <WILDCARD> | <A> | <a> | <c> | <n> | <o>)
    {
        jjtn000.setSymbol(token.image);
    }
    ( <NUMBER> )?/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LogicalExpression()                    : {/*@bgen(jjtree) LogicalExpression */
  ASTLogicalExpression jjtn000 = new ASTLogicalExpression(JJTLOGICALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalExpression */
    try {
/*@egen*/
    <L_BRACKET> LowAndExpression() <R_BRACKET> ( <NUMBER> )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// TODO: This requires a fully implemented SMARTSAtom API (or something else) that 
// could encapsulate logical criterias
void LowAndExpression()                   : {/*@bgen(jjtree) LowAndExpression */
  ASTLowAndExpression jjtn000 = new ASTLowAndExpression(JJTLOWANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LowAndExpression */
    try {
/*@egen*/
    OrExpression() ( <L_AND> LowAndExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void OrExpression()               : {/*@bgen(jjtree) OrExpression */
  ASTOrExpression jjtn000 = new ASTOrExpression(JJTOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrExpression */
    try {
/*@egen*/
    ExplicitHighAndExpression() ( <OR> OrExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExplicitHighAndExpression()                            : {/*@bgen(jjtree) ExplicitHighAndExpression */
  ASTExplicitHighAndExpression jjtn000 = new ASTExplicitHighAndExpression(JJTEXPLICITHIGHANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExplicitHighAndExpression */
    try {
/*@egen*/
    ( ImplicitHighAndExpression() ) ( <H_AND> ExplicitHighAndExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImplicitHighAndExpression()                            : {/*@bgen(jjtree) ImplicitHighAndExpression */
  ASTImplicitHighAndExpression jjtn000 = new ASTImplicitHighAndExpression(JJTIMPLICITHIGHANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImplicitHighAndExpression */
    try {
/*@egen*/
    NotExpression() ( ImplicitHighAndExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/  
}

void NotExpression()                : 
{/*@bgen(jjtree) NotExpression */
  ASTNotExpression jjtn000 = new ASTNotExpression(JJTNOTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ jjtn000.setType(SMARTSParserConstants.DEFAULT); }
{/*@bgen(jjtree) NotExpression */
    try {
/*@egen*/
    [ <NOT> { jjtn000.setType(SMARTSParserConstants.NOT); } ] 
    ( PrimitiveAtomExpression() | RecursiveSmartsExpression() )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RecursiveSmartsExpression()                            : {/*@bgen(jjtree) RecursiveSmartsExpression */
  ASTRecursiveSmartsExpression jjtn000 = new ASTRecursiveSmartsExpression(JJTRECURSIVESMARTSEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RecursiveSmartsExpression */
    try {
/*@egen*/
    <DOLLAR> <L_PAREN> SmartsExpression() <R_PAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PrimitiveAtomExpression() : {}
{
    (
        NoHydrogenElement() 
        |
        AnyAtom()
        |
        Aromatic()
        |
        Aliphatic()
        |
        Degree()
        |
        TotalHCount()
        |
        ImplicitHCount()
        |
        RingMembership()
        |
        RingSize()
        |
        Valence()
        |
        TotalConnectivity()
        |
        RingConnectivity()
        |
        Charge()
        |
        AtomicNumber()
        |
        Chirality()
    )
}

void TotalHCount()              : {/*@bgen(jjtree) TotalHCount */
  ASTTotalHCount jjtn000 = new ASTTotalHCount(JJTTOTALHCOUNT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TotalHCount */
    try {
/*@egen*/
    <H> { jjtn000.setCount(1); } [ <NUMBER> { jjtn000.setCount( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImplicitHCount()                : {/*@bgen(jjtree) ImplicitHCount */
  ASTImplicitHCount jjtn000 = new ASTImplicitHCount(JJTIMPLICITHCOUNT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImplicitHCount */
    try {
/*@egen*/
    <h> { jjtn000.setCount(1); } [ <NUMBER> { jjtn000.setCount( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Degree()         : {/*@bgen(jjtree) Degree */
  ASTDegree jjtn000 = new ASTDegree(JJTDEGREE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Degree */
    try {
/*@egen*/
    <D> { jjtn000.setDegree(1); } [ <NUMBER> { jjtn000.setDegree( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AtomicNumber()               : {/*@bgen(jjtree) AtomicNumber */
  ASTAtomicNumber jjtn000 = new ASTAtomicNumber(JJTATOMICNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AtomicNumber */
    try {
/*@egen*/
    "#" <NUMBER>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.setNumber( Integer.parseInt(token.image) ); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Charge()         : {/*@bgen(jjtree) Charge */
                          ASTCharge jjtn000 = new ASTCharge(JJTCHARGE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token charge; }
{/*@bgen(jjtree) Charge */
    try {
/*@egen*/
    // Here I am assuming nobody will write anything like -----------... for more than 8, instead, use -<n>
    LOOKAHEAD(2)
    "+" { jjtn000.setPositive(true); jjtn000.setCharge(1); } [ charge = <NUMBER> { jjtn000.setCharge( Integer.parseInt(charge.image) ); } ]
    | "-" { jjtn000.setPositive(false); jjtn000.setCharge(1); } [ charge = <NUMBER> { jjtn000.setCharge( Integer.parseInt(charge.image) ); } ]
    | "--"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/          { jjtn000.setPositive(false); jjtn000.setCharge(2); }
    | "---"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/         { jjtn000.setPositive(false); jjtn000.setCharge(3); }
    | "----"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/        { jjtn000.setPositive(false); jjtn000.setCharge(4); }
    | "-----"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/       { jjtn000.setPositive(false); jjtn000.setCharge(5); }
    | "------"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/      { jjtn000.setPositive(false); jjtn000.setCharge(6); }
    | "-------"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/     { jjtn000.setPositive(false); jjtn000.setCharge(7); } 
    | "--------"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/    { jjtn000.setPositive(false); jjtn000.setCharge(8); }
    | "++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/          { jjtn000.setPositive(true); jjtn000.setCharge(2); }   
    | "+++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/         { jjtn000.setPositive(true); jjtn000.setCharge(3); }
    | "++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/        { jjtn000.setPositive(true); jjtn000.setCharge(4); }
    | "+++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/       { jjtn000.setPositive(true); jjtn000.setCharge(5); }
    | "++++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/      { jjtn000.setPositive(true); jjtn000.setCharge(6); }
    | "+++++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/     { jjtn000.setPositive(true); jjtn000.setCharge(7); }
    | "++++++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/    { jjtn000.setPositive(true); jjtn000.setCharge(8); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void RingConnectivity()                   : {/*@bgen(jjtree) RingConnectivity */
  ASTRingConnectivity jjtn000 = new ASTRingConnectivity(JJTRINGCONNECTIVITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RingConnectivity */
    try {
/*@egen*/
    <x> { jjtn000.setNumOfConnection(1); } 
    [ <NUMBER> { jjtn000.setNumOfConnection( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TotalConnectivity()                    : {/*@bgen(jjtree) TotalConnectivity */
  ASTTotalConnectivity jjtn000 = new ASTTotalConnectivity(JJTTOTALCONNECTIVITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TotalConnectivity */
    try {
/*@egen*/
    <X> { jjtn000.setNumOfConnection(1); } 
    [ <NUMBER> { jjtn000.setNumOfConnection( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Valence()          : {/*@bgen(jjtree) Valence */
  ASTValence jjtn000 = new ASTValence(JJTVALENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Valence */
    try {
/*@egen*/
    <v> { jjtn000.setOrder(1); } 
    [ <NUMBER> { jjtn000.setOrder( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RingMembership()                 : {/*@bgen(jjtree) RingMembership */
  ASTRingMembership jjtn000 = new ASTRingMembership(JJTRINGMEMBERSHIP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RingMembership */
    try {
/*@egen*/
    <R> { jjtn000.setNumOfMembership(1); } 
    [ <NUMBER> { jjtn000.setNumOfMembership( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RingSize()           : {/*@bgen(jjtree) RingSize */
  ASTRingSize jjtn000 = new ASTRingSize(JJTRINGSIZE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RingSize */
    try {
/*@egen*/
    <r> { jjtn000.setSize(1); } 
    [ <NUMBER> { jjtn000.setSize( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Aliphatic()            : {/*@bgen(jjtree) Aliphatic */
  ASTAliphatic jjtn000 = new ASTAliphatic(JJTALIPHATIC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Aliphatic */
    try {
/*@egen*/
    <A>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void Aromatic()           : {/*@bgen(jjtree) Aromatic */
  ASTAromatic jjtn000 = new ASTAromatic(JJTAROMATIC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Aromatic */
    try {
/*@egen*/
    <a>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AnyAtom()          : {/*@bgen(jjtree) AnyAtom */
  ASTAnyAtom jjtn000 = new ASTAnyAtom(JJTANYATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AnyAtom */
    try {
/*@egen*/
    <WILDCARD>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AtomicMass()             : {/*@bgen(jjtree) AtomicMass */
  ASTAtomicMass jjtn000 = new ASTAtomicMass(JJTATOMICMASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AtomicMass */
    try {
/*@egen*/
    <NUMBER>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { jjtn000.setMass( Integer.parseInt(token.image) ); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Chirality()            : {/*@bgen(jjtree) Chirality */
  ASTChirality jjtn000 = new ASTChirality(JJTCHIRALITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Chirality */
    try {
/*@egen*/
    LOOKAHEAD(2)
    "@" | "@@"/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NoHydrogenElement()         : {/*@bgen(jjtree) Element */
  ASTElement jjtn000 = new ASTElement(JJTELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Element */
        try {
/*@egen*/
	(
    <HE> | <LI> | <BE> | <NE> | <NA> | <MG> | <AL> | <SI> | <AR> | <CA> | <SC> |
    <TI> | <CR> | <MN> | <FE> | <CO> | <NI> | <CU> | <ZN> | <GA> | <GE> | <AS> |
    <SE> | <BR> | <KR> | <RB> | <SR> | <ZR> | <NB> | <MO> | <TC> | <RU> | <RH> |
    <PD> | <AG> | <CD> | <IN> | <SN> | <SB> | <TE> | <XE> | <CS> | <BA> | <LA> |
    <HF> | <TA> | <RE> | <OS> | <IR> | <PT> | <AU> | <HG> | <TL> | <PB> | <BI> |
    <PO> | <AT> | <RN> | <FR> | <RA> | <AC> | <TH> | <PA> | <CL> |
	<B> | <C> | <N> | <O> | <F> | <P> | <S> | <K> | <V> | <Y> | <I> | <U> | 
    <c> | <o> | <n>
    )
    {
        jjtn000.setSymbol(token.image);
    }
    ( <NUMBER> )?/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}