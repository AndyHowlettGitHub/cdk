

options {
STATIC=false;
OPTIMIZE_TOKEN_MANAGER=true;
FORCE_LA_CHECK=true;
}

PARSER_BEGIN(SMARTSParser)
package org.openscience.cdk.smiles.smarts;
import java.io.StringReader;
import org.openscience.cdk.Atom;
import org.openscience.cdk.ChemObject;
import org.openscience.cdk.config.IsotopeFactory;
import org.openscience.cdk.exception.CDKException;
import org.openscience.cdk.isomorphism.matchers.IQueryAtom;
import org.openscience.cdk.isomorphism.matchers.IQueryBond;
import org.openscience.cdk.isomorphism.matchers.QueryAtomContainer;
import org.openscience.cdk.isomorphism.matchers.SymbolQueryAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.AliphaticAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.AnyAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.AnyOrderQueryBond;
import org.openscience.cdk.isomorphism.matchers.smarts.AromaticAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.AromaticQueryBond;
import org.openscience.cdk.isomorphism.matchers.smarts.DegreeAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.FormalChargeAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.ImplicitHCountAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.SMARTSAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.SMARTSBond;
import org.openscience.cdk.isomorphism.matchers.smarts.TotalHCountAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.OrderQueryBond;
import org.openscience.cdk.isomorphism.matchers.smarts.RingAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.TotalRingConnectionAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.OperatorContainer;
import org.openscience.cdk.isomorphism.matchers.smarts.SMARTSOperatorAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.TotalConnectionAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.ColumnAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.BracketAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.RecurseAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.MassAtom;
import org.openscience.cdk.isomorphism.matchers.smarts.TotalValencyAtom;
import org.openscience.cdk.tools.LoggingTool;

/* $RCSfile$
 * $Original Author: egonw $
 * $code extension: sushil ronghe$
 * $Date: 2007-04-18 (Wed, 18 April 2007) $
 * $Revision: 6382 $
 *
 * Copyright (C) 2004-2007  The Chemistry Development Kit (CDK) project
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * (or see http://www.gnu.org/copyleft/lesser.html)
 */

/**
 * This parser implements a nearly complete subset of the SMARTS syntax as defined on
 * <a href="http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html">the
 * Daylight website</a>. 
 *
 * <p>Example code using SMARTS substructure search looks like:
 * <pre>
 * SmilesParser sp = new SmilesParser();
 * AtomContainer atomContainer = sp.parseSmiles("CC(=O)OC(=O)C");
 * QueryAtomContainer query = SMARTSParser.parse("C*C");
 * boolean queryMatch = UniversalIsomorphismTester.isSubgraph(atomContainer, query);
 * </pre>
 *
 * <p>See the cdk.test.smiles.smarts.ParserTest for examples of the implemented
 * subset.
 *
 * @see org.openscience.cdk.isomorphism.matchers.smarts.SMARTSAtom
 *
 * @author      Sushil Ronghe
 * @cdk.created 2007-04-29
 *
 * @cdk.require ant1.6
 * @cdk.module  smarts
 *
 * @cdk.keyword SMARTS
 * @cdk.keyword substructure search
 */
public class SMARTSParser {
    
    private IQueryAtom previousAtom = null;
    private SMARTSBond currentBond = null;
    private QueryAtomContainer lastatomcontainer = new QueryAtomContainer ();
    private IQueryAtom lastatom; 
    private QueryAtomContainer container = null;
    private QueryAtomContainer  atomcontainer = new QueryAtomContainer ();
    private QueryAtomContainer smartexpress = new QueryAtomContainer();
    private static boolean bstart=false;
    private static boolean cstart=false;
    private static boolean rstart=false;
    private int columncounter=0;
    private OperatorContainer OperMap = new OperatorContainer();
    private final static LoggingTool logger = new LoggingTool(SMARTSParser.class);
    
    public static QueryAtomContainer parse(String stringToParse) throws CDKException {
        QueryAtomContainer container = null;
        
        StringReader stringReader = new StringReader(stringToParse);
        try {
            SMARTSParser parser = new SMARTSParser(stringReader);
            container = parser.Parse(); 
        } catch (ParseException exception) {
            throw new CDKException("The string " + stringToParse + " is not a valid" +
              " SMARTS string: " + exception.getMessage(), exception);          
        }
        catch(Exception ex){
             ex.printStackTrace();
        }
        return container;
    }
    
}
PARSER_END(SMARTSParser)

JAVACODE
void StartRecursion(){
     rstart = true;
}
JAVACODE
void AddStartBracket(){
  if(rstart){}
  else{
   logger.debug("Bracket start is on: ");
   container.addAtom(new BracketAtom());
   bstart = true;
  }
   
}
JAVACODE
void AddEndBracket(){
   logger.debug("Bracket end: ");
  if(rstart && !bstart){rstart= false;}
   
  else if(bstart)
   caseBraket();
}
JAVACODE
void caseBraket(){
SMARTSOperatorAtom atom;
   while(!(container.getLastAtom() instanceof BracketAtom)){
      IQueryAtom tempatom = (IQueryAtom)container.getLastAtom();
      atomcontainer.addAtom(tempatom);
      container.removeAtom(tempatom);
   }
   IQueryAtom BA =(IQueryAtom)container.getLastAtom();
   container.removeAtom(BA);
   if(OperMap.size()<1){
    atom = new SMARTSOperatorAtom(atomcontainer);
   }
   else{
     atom = new SMARTSOperatorAtom(atomcontainer,OperMap);
   }
   container.addAtom(atom);
   /////////////////////////////////////////////////////////////////
   if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
   /////////////////////////////////////////////////////////////////
   bstart = false;
   OperMap = new OperatorContainer();
   atomcontainer = new QueryAtomContainer();
}
JAVACODE
/** Detect a column start i.e. "("
   * and store it in a columncounter
   */
void AddStartColumn(){
   logger.debug("Column start is on: ");
   if(!cstart){
      cstart = true;
      lastatom = (IQueryAtom)container.getLastAtom();
      columncounter++;
   }
   if(cstart){
     lastatomcontainer.addAtom((IQueryAtom)container.getLastAtom());
     columncounter++;
  }

}
JAVACODE
/** Detect a column end i.e. ")"
  * and store it in a columncounter
  **/
void AddEndColumn(){
   logger.debug("Column end is on: ");
   columncounter--;
  if(rstart && !cstart){
     rstart= false;
  }
  else if(cstart){
   if(columncounter == 1){
      previousAtom = lastatom;
      lastatomcontainer = new QueryAtomContainer();
      cstart = false;
   }
   else if(lastatomcontainer.getAtomCount() > 0){
      previousAtom = (IQueryAtom)lastatomcontainer.getLastAtom();
      
   }
   else{
      cstart = false;
    }
 }
   
}

JAVACODE
/** Add mass atom (token --> Z) to atom container
  **/
void AddMassAtom(){
   Token tok = getToken(-1);
   logger.debug("Adding Mass Atom: "+ tok.image);
   MassAtom atom = new MassAtom(Integer.parseInt(tok.image));
   container.addAtom(atom);
   if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}
JAVACODE
/** Add any atom (token --> *) to atom container
  **/
void AddAnyAtom() {
    Token tok = getToken(-1);
    logger.debug("Adding SMARTS atom: " + tok.image);
    AnyAtom atom = new AnyAtom();
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}
JAVACODE
/** Add aliphatic atom (token --> A) to atom container
  **/
void AddAliphaticAtom() {
    logger.debug("Adding aliphatic atom");
    AliphaticAtom atom = new AliphaticAtom();
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }

 }

JAVACODE
/** Add aromatic atom (token --> element symbol small letter) to atom container
  **/
void AddELementAromaticAtom(){
    Token tok = getToken(-1);
    logger.debug("Adding aromatic atom");
    String ss = new String(tok.image);
    AromaticAtom atom = new AromaticAtom(new Atom(ss.toUpperCase()));
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}

JAVACODE
/** Add aromatic atom (token --> a) to atom container
  **/
void AddAromaticAtom() {
    logger.debug("Adding aromatic atom");
    AromaticAtom atom = new AromaticAtom();
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }

}

JAVACODE
/** Add bond to the bond container.
  **/
void AddCurrentBond(IQueryAtom atom, IQueryAtom atom2) {
    if (currentBond == null) {
        // add default bond
        currentBond = new AnyOrderQueryBond();
    }
    Atom[] atoms = new Atom[2];
    atoms[0] = (Atom)atom;
    atoms[1] = (Atom)atom2;
    currentBond.setAtoms(atoms);
    container.addBond(currentBond);
    currentBond = null;
}

JAVACODE
/** Add  atom (token --> elemenet) to atom container
  **/
void AddNewElementAtom() {
    Token tok = getToken(-1);
    logger.debug("Adding SMARTS atom: " + tok.image);
    SymbolQueryAtom atom = new SymbolQueryAtom(new Atom(tok.image));
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}
JAVACODE
/** Add atom (token --> X) to atom container
  **/
void AddTotalConnectionAtom(){
     TotalConnectionAtom atom;
     Token tok = getToken(-1);
     logger.debug("adding smarts atoms:" + tok.image);
     String ss = new String(tok.image);
     if(ss=="X"){
         atom = new TotalConnectionAtom();
     }
     else{
        atom=new TotalConnectionAtom(Integer.parseInt(tok.image));
     }
     container.addAtom(atom);
     if(!bstart ){
     if (previousAtom != null) AddCurrentBond(previousAtom, atom);
     previousAtom = atom;
    }
     
}


JAVACODE
/** Add atom (token --> Atomic Number) to atom container
  **/
void AddNewNumberAtom() {
    Token tok = getToken(0);
    logger.debug("Adding SMARTS atom: " + tok.image);
    try {
        String sym = IsotopeFactory.getInstance(new ChemObject().getBuilder()).getElement(Integer.parseInt(tok.image)).getSymbol();
        SymbolQueryAtom atom = new SymbolQueryAtom(new Atom(sym));
        container.addAtom(atom);
        if(!bstart ){
        if (previousAtom != null) AddCurrentBond(previousAtom, atom);
          previousAtom = atom;
        }
    } catch (Exception exp) {
        logger.debug("Exception caught: " + exp);
    }
}

JAVACODE
/** Add atom (token --> D) to atom container
  **/
void AddNewDegreeAtom() {
    DegreeAtom atom;
    Token tok = getToken(-1);
    logger.debug("Adding SMARTS degree atom: " + tok.image);
    String ss = new String(tok.image);
    if(ss.equals("D")){
    atom=new DegreeAtom();
    }
    else{
    atom=new DegreeAtom(Integer.parseInt(tok.image));
    } 
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}

JAVACODE
/** Add atom (token --> +/-) to atom container
  **/
void AddNewFormalChargeAtom() {
    Token tok = getToken(-1);
    FormalChargeAtom atom;
    logger.debug("Adding SMARTS formal charge atom: " + tok.image);
    String ss = new String(tok.image);
    if(ss.equals("+") || ss.equals("-"))
     atom = new FormalChargeAtom(1);
    else
     atom = new FormalChargeAtom(Integer.parseInt(tok.image));
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}
JAVACODE
/** Add atom (token --> r) to atom container
  **/
void AddNewRingAtom(){
RingAtom atom;
Token tt = getToken(-1);
logger.debug("adding SMARTS Ring atom: "+ tt.image);
String ss = new String(tt.image);
if(ss.equals("r")){
    atom=new RingAtom();
}
else{
    atom=new RingAtom(Integer.parseInt(tt.image));
} 
container.addAtom(atom);
if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}
JAVACODE
/** Add atom (token --> x) to atom container
  **/
void AddTotalRingConnectionAtom(){
TotalRingConnectionAtom atom;
Token tt = getToken(-1);
logger.debug("adding SMARTS format charge atom: "+ tt.image);
String ss = new String(tt.image);
if(ss.equals("x")){
    atom=new TotalRingConnectionAtom();
}
else{
    atom=new TotalRingConnectionAtom(Integer.parseInt(tt.image));
} 
container.addAtom(atom);
if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}
JAVACODE
/** Count the number of signs encounter at once 
  **/
int getSignCount(String sss) {
    int count=0;
    for (int i=0;i<sss.length();i++){
            if(sss.charAt(i)=='+'|sss.charAt(i)=='-'){
                count++;
            }
        }
 return count; 
}

JAVACODE
/** Add atom (token --> h) to atom container
  **/
void AddNewImplicitHCountAtom() {
    ImplicitHCountAtom atom;
    Token tok = getToken(-1);
    logger.debug("Adding SMARTS implicit Hcount atom: " + tok.image);
    String ss = new String(tok.image);
    if(ss.equals("h")){
     atom=new ImplicitHCountAtom();
    }
    else{
    atom=new ImplicitHCountAtom(Integer.parseInt(tok.image));
    } 
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}

JAVACODE
/** Add atom (token --> H) to atom container
  **/
void AddNewTotalHCountAtom() {
    TotalHCountAtom atom;
    Token tok = getToken(-1);
    logger.debug("Adding SMARTS total Hcount atom: " + tok.image);
    String ss = new String(tok.image);
    if(ss.equals("H")){
     atom=new TotalHCountAtom();
    }
    else{
    atom=new TotalHCountAtom(Integer.parseInt(tok.image));
    } 
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
}
JAVACODE
/** Add atom (token --> v) to atom container
  **/
void AddValencyAtom(){
  TotalValencyAtom atom;
  Token tok = getToken(-1);
    logger.debug("Adding SMARTS total Hcount atom: " + tok.image);
    String ss = new String(tok.image);
    if(ss.equals("v")){
     atom=new TotalValencyAtom();
    }
    else{
    atom=new TotalValencyAtom(Integer.parseInt(tok.image));
    } 
    container.addAtom(atom);
    if(!bstart ){
    if (previousAtom != null) AddCurrentBond(previousAtom, atom);
    previousAtom = atom;
  }
  
}
JAVACODE
/** Add operator expression (token --> ! , & ;) to atom container
  **/
void AddOperator(){
    Token tok = getToken(-1);  
  try{    
      OperMap.addElement(tok.image);
     }
    catch(java.lang.NullPointerException NPT){
     //System.out.println("error caught");
      NPT.printStackTrace();
   }
    
}
JAVACODE
/** Add atom Operator atom.Operator atom deals with the
 * smarts atom and operator expression at once. 
  **/
void AddOperatorAtom(){
    Token tok = getToken(-1);
    logger.debug("Adding SMARTS total OP atom: " + tok.image);
    container.setOperator("!");
    
}
JAVACODE
/** Set Current bond to the order of given argument.
  **/
void SetCurrentBondToOrderQuery(double order) {
    currentBond = new OrderQueryBond();
    currentBond.setOrder(order);
}

JAVACODE
/** Set Current bond to the order of default.
  **/
void SetCurrentBondToAnyOrder() {
    currentBond = new AnyOrderQueryBond();
}

JAVACODE
/** Set Current bond to the order of aromatic atom
  **/
void SetCurrentBondToAromatic() {
    currentBond = new AromaticQueryBond();
}
/** Main Parsing Method that will return the query atom container
  **/
QueryAtomContainer Parse() :
{}
{
    { 
        container = new QueryAtomContainer();
        previousAtom = null;
    }
    ((SMARTS())+ |ConsumeToken()) <EOF>
    { return container; }
}
/**
*Atom Parsing Method that will return the query atom container
**/
void SMARTS() :
{}
{
    (AtomExpression()) [ BondExpression() ] 
}
/**
*Bond Parsing Method that will return the query atom container
**/
void BondExpression() :
{}
{
    
    ("=" SetCurrentBondToOrderQuery(2.0) ) | 
    (<HASH> SetCurrentBondToOrderQuery(3.0) ) | 
    (":" SetCurrentBondToAromatic() ) | 
    ("~" SetCurrentBondToAnyOrder() )
}
/**
*An important parsing method work like a engine.
 *see particular parsing method for detail
**/
void AtomExpression():
{}
{
    (
     "*" AddAnyAtom()        |
     "a" AddAromaticAtom()   |
     "A" AddAliphaticAtom()  |
     Recursion()             |
     Element()               |
     StartBracket()          |
     EndBracket()            |
     StartColumn()           |
     EndColumn()             |
     Degree()                |
     TotalHCount()           | 
     ImplicitHCount()        |    
     TotalRingConnection()   |
     RingAtom()              | 
     AtomicNumber()          |
     AromaticAtms()          |
     TotalConnectionAtom()   |
     OperatorAtom()          |
     Operator()              |
     ChargeAtom()            |
     MassAtom()              
            
    )  
}
/**
*Parsing Method
**/
void ConsumeToken():
{}
{
    <DOT> 
}
/**
*Parsing Method
**/
void OperatorAtom():
{}
{
     <excl> AtomExpression() AddOperatorAtom()
}
/**
*Parsing Method
**/
void MassAtom():
{}
{
     <DIGIT> AddMassAtom()
}
/**
*Parsing Method
**/
void StartBracket():
{}
{
    <STARTOFBRACKET> AddStartBracket()
}
/**
*Parsing Method
**/
void Recursion():
{}
{
   <$> [<STARTOFBRACKET>|<STARTOFCOLUMN>] StartRecursion()
}
/**
*Parsing Method
**/
void EndBracket():
{}
{
    <ENDOFBRACKET>  AddEndBracket()
}
/**
*Parsing Method
**/
void StartColumn():
{}
{
    <STARTOFCOLUMN> AddStartColumn()
}
/**
*Parsing Method
**/
void EndColumn():
{}
{
    <ENDOFCOLUMN>  AddEndColumn()
}
/**
*Parsing Method
**/

void AtomicNumber() :
{}
{
    <HASH> (<DIGIT> | <DIGITS>)  AddNewNumberAtom()
}
/**
*Parsing Method
**/

void TotalHCount() :
{}
{
	<H> [<DIGIT>] AddNewTotalHCountAtom()
}
/**
*Parsing Method
**/
void Element() :
{}
{
	(TwoCharElement() | OneCharElement())
        AddNewElementAtom()
}
/**
*Parsing Method
**/

void ChargeAtom():
{Token t;}
{
        ("+"|"-") [<DIGIT>]AddNewFormalChargeAtom()
}
/**
*Parsing Method
**/
void ValenyAtom():
{}
{
      <v> [<DIGIT>] AddValencyAtom()
}
/**
*Parsing Method
**/
void ImplicitHCount() :
{}
{
	<h> [<DIGIT>] AddNewImplicitHCountAtom()
}
/**
*Parsing Method
**/
void Degree() :
{}
{
	<D> [<DIGIT>] AddNewDegreeAtom()
}
/**
*Parsing Method
**/
void RingAtom() :
{}
{
        
        <r> [<DIGIT>] AddNewRingAtom()
}
/**
*Parsing Method
**/
void TotalRingConnection():
{}
{
        <x> [<DIGIT>] AddTotalRingConnectionAtom()
}
/**
*Parsing Method
**/
void TotalConnectionAtom():
{}
{
        <X> [<DIGIT>] AddTotalConnectionAtom()
}
/**
*Parsing Method
**/
void TwoCharElement() :
{}
{
    <HE> | <LI> | <BE> | <NE> | <NA> | <MG> | <AL> | <SI> | <AR> | <CA> | <SC> |
    <TI> | <CR> | <MN> | <FE> | <CO> | <NI> | <CU> | <ZN> | <GA> | <GE> | <AS> |
    <SE> | <BR> | <KR> | <RB> | <SR> | <ZR> | <NB> | <MO> | <TC> | <RU> | <RH> |
    <PD> | <AG> | <CD> | <IN> | <SN> | <SB> | <TE> | <XE> | <CS> | <BA> | <LA> |
    <HF> | <TA> | <RE> | <OS> | <IR> | <PT> | <AU> | <HG> | <TL> | <PB> | <BI> |
    <PO> | <AT> | <RN> | <FR> | <RA> | <AC> | <TH> | <PA> | <CL>
}
/**
*Parsing Method
**/
void OneCharElement() :
{}
{
	 <B> | <C> | <N> | <O> | <F> | <P> | <S> | <K> | <V> | <Y> | <I> | <U>
        
}
/**
*Parsing Method
**/
void Operator():
{}
{
   (<coln>|<coma>|<amps>)   AddOperator()  
}
/**
*Parsing Method
**/
void AromaticAtms():
{}
{
   (<c>|<n>|<o>|<p>|<s>)  AddELementAromaticAtom()
}
/**
*Token Library
**/
TOKEN:
{
    < DIGIT: ["0"-"9"] >
}

TOKEN:
{
    <SIGN: ["+","-"] >
}
TOKEN:
{
    <SIGNS: (["+","-"])+>
}
TOKEN:
{
   <$:"$">
}
TOKEN: /* Opetator*/
{
    < excl: "!" >
}
TOKEN:
{
    < amps :"&"  >
}
TOKEN:
{
    <coma:",">
}
TOKEN:
{
    <coln:";">
}
TOKEN:
{
    <h:"h">
}
TOKEN:
{
    <D:"D">
}
TOKEN:
{
   <X:"X">
}
TOKEN:
{
     <r:"r">
}
TOKEN:
{
     <DOT:".">
}
TOKEN:
{
    <x:"x">
}
TOKEN:
{
   <v:"v">
}
TOKEN:
{
    <HASH:"#">
}
TOKEN:
{
    <STARTOFBRACKET:"[">
}
TOKEN:
{
    <ENDOFBRACKET:"]">
}
TOKEN:
{
    <STARTOFCOLUMN:"(">
}
TOKEN:
{
   <ENDOFCOLUMN:")">
}
TOKEN :
{
    < DIGITS: (["0"-"9"])+ >
}
TOKEN :
{
    <c:"c">
   |<n:"n">
   |<o:"o">
   |<s:"s">
   |<p:"p">
}

TOKEN : /* ELEMENTS */
{
    <  H: "H" >
|   < HE: "He" >
|   < LI: "Li" >
|   < BE: "Be" >
|   <  B: "B" >
|   <  C: "C" >
|   <  N: "N" >
|   <  O: "O" >
|   <  F: "F" >
|   < NE: "Ne" >
|   < NA: "Na" >
|   < MG: "Mg" >
|   < AL: "Al" >
|   < SI: "Si" >
|   <  P: "P" >
|   <  S: "S" >
|   < CL: "Cl" >
|   < AR: "Ar" >
|   <  K: "K" >
|   < CA: "Ca" >
|   < SC: "Sc" >
|   < TI: "Ti" >
|   <  V: "V" >
|   < CR: "Cr" >
|   < MN: "Mn" >
|   < FE: "Fe" >
|   < CO: "Co" >
|   < NI: "Ni" >
|   < CU: "Cu" >
|   < ZN: "Zn" >
|   < GA: "Ga" >
|   < GE: "Ge" >
|   < AS: "As" >
|   < SE: "Se" >
|   < BR: "Br" >
|   < KR: "Kr" >
|   < RB: "Rb" >
|   < SR: "Sr" >
|   <  Y: "Y" >
|   < ZR: "Zr" >
|   < NB: "Nb" >
|   < MO: "Mo" >
|   < TC: "Tc" >
|   < RU: "Ru" >
|   < RH: "Rh" >
|   < PD: "Pd" >
|   < AG: "Ag" >
|   < CD: "Cd" >
|   < IN: "In" >
|   < SN: "Sn" >
|   < SB: "Sb" >
|   < TE: "Te" >
|   <  I: "I" >
|   < XE: "Xe" >
|   < CS: "Cs" >
|   < BA: "Ba" >
|   < LA: "La" >
|   < HF: "Hf" >
|   < TA: "Ta" >
|   <  W: "W" >
|   < RE: "Re" >
|   < OS: "Os" >
|   < IR: "Ir" >
|   < PT: "Pt" >
|   < AU: "Au" >
|   < HG: "Hg" >
|   < TL: "Tl" >
|   < PB: "Pb" >
|   < BI: "Bi" >
|   < PO: "Po" >
|   < AT: "At" >
|   < RN: "Rn" >
|   < FR: "Fr" >
|   < RA: "Ra" >
|   < AC: "Ac" >
|   < TH: "Th" >
|   < PA: "Pa" >
|   <  U: "U" >
}
