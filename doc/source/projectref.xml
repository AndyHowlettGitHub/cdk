<section> 
  <title>Programmers Reference</title>	
  <section> 
	 <title>Introduction</title>
	 	<para> 
	 	This chapter provides an overview about how to use the Chemistry
		Develoment Kit (CDK) as a programmer in order to solve problems in
		chemoinformatics. The single most important advantage of using the programming
		language Java is probably its clear object orientation. It allows the
		programmer to directly transfer and apply ideas originating in the real world
		to the world of computer programming. We felt a strong dedication to this
		concept when creating the CDK. Another concept we concisely followed is the
		Model/View/Controller paradigm. Any computer program can be separated into a
		controller, a model and a view. The model holds the pure data on which the
		program in operates in the form best suited to achieve the desired computation
		most efficiently. The view is an external representation of this data, such
		that is can be most efficiently percepted by the user. The controller is the
		part that allows the user to interact with the program, in the broadest sense
		to customize the view. Even a command line driven utility like "grep" consists
		of these three parts. One can achieve a particularly good program design by
		clearly separating the parts of a program responsible for the controlling part,
		the viewing part and the data storage part. If the interfaces of each of the
		three parts are clearly defined, it allows the programmer to plug-in a
		different controller or a different view independently without having to change
		any of the other two parts. 
		</para>
		<para> 
			In our context of chemistry the model
			would be an internal representation of a molecule, a chemical reaction, an
			ensemble of molcecules, etc.
		</para>
		<para>
			There can be multiple VIEWs of the same model
			<itemizedlist>
				<listitem>
					<para>
						a 2D representation like the one in JChemPaint, consisting mainly of
						lines, representing bonds and some Elementsymbols, or
					</para>
				</listitem>
				<listitem>
					<para>
						a 3D representation, rotatable, nicely shaded with perspective scaling.
					</para>
				</listitem>
                                <listitem>
                                        <para>
                                                a textual representation for manual inspection and editing of properties
                                                of primary CDK elements. Most common form are table representing such data.
                                                High level tables can also be used as a GUI for databases.
                                        </para>
                                </listitem>
			</itemizedlist>
		</para>
		<para>
			The CONTROLER gives the user means of manipulating how the VIEW of the
			MODEL is supposed to look like, e.g. for rotating a molecule in the 3D
			view. But is also may provide a way of manipulating the model, so that a
			user of JChemPaint can, for example, remove a bond from a molecule, etc.
		</para>
		<para>
			Cleanly separating these parts, using well-defined interfaces between
			them, gives you great flexibility. Making an applet out of JChemPaint,
			i.e. plugin a Java 1.1.8 GUI where there is now a Browser-incompatible
			Java 2 interface, would be much easier if JCP was nicely designed using
			the MVC paradigm.
		</para>

  </section> 
  <section> 
	 <title>The Base Classes</title> 
	 <para>The base classes are located in the top level hierarchy of the CDK, which is
	  org.openscience.cdk.
	  A chemist will find many of his/her well known concepts implemented
		as classes in the CDK:
		<itemizedlist>
                        <listitem><para>&Element;</para></listitem>
                        <listitem><para>&Isotope;</para></listitem>
			<listitem><para>&Atom;</para></listitem>
                        <listitem><para>&Bond;</para></listitem>
                        <listitem><para>&Molecule;</para></listitem>
			<listitem>
				<para>
					<ulink
					url="api/org/openscience/cdk/Ring.html">Ring</ulink>

				</para>
			</listitem>
			<listitem>
				<para>
					etc.
				</para>
			</listitem>
		</itemizedlist>

		A molecule is build by creating an instance of the Molecule.class and the
		successivly adding instances of &Atom;.class and &Bond;.class to the Molecule
		container: 
		<example>
		  <title>Creating a Molecule</title>
		  <programlisting>public static Molecule makeAlphaPinene()
{
	Molecule mol = new Molecule();
	mol.addAtom(new Atom("C")); 
	mol.addAtom(new Atom("C")); 
	mol.addAtom(new Atom("C")); 
	mol.addAtom(new Atom("C")); 
	mol.addAtom(new Atom("C")); 
	mol.addAtom(new Atom("C")); 
	mol.addAtom(new Atom("C")); 
	mol.addAtom(new Atom("C")); 
	mol.addAtom(new Atom("C"));  
	mol.addAtom(new Atom("C")); 
	
	mol.addBond(new Bond(mol.getAtomAt(0), mol.getAtomAt(1), 2)); // One way of making a double bond 
	mol.addBond(1, 2, 1); // A much shorter way of adding a bond
	mol.addBond(2, 3, 1); 
	mol.addBond(3, 4, 1); 
	mol.addBond(4, 5, 1); 
	mol.addBond(5, 0, 1); 
	mol.addBond(0, 6, 1); 
	mol.addBond(3, 7, 1); 
	mol.addBond(5, 7, 1); 
	mol.addBond(7, 8, 1); 
	mol.addBond(7, 9, 1); 
	return mol;
}
</programlisting> 
</example>
	</para> 
	 <para> Since there are a number of concepts in chemistry that have
		properties very similar to a molecule, the Molecule is not the actual base
		class that has all the addBond(Bond), addAtom(Atom) and other methods that you
		would probly exspect in it. The base class in fact the 
		<ulink url="api/org/openscience/cdk/AtomContainer.html">AtomContainer.class</ulink>
		which is then subclassed by classes like Ring, Substructure, etc. Thus, if you
		want to know what a Molecule, a Ring, a Substructure can do, look at the
		JavaDoc documentation of the AtomContainer class first and then at the
		specialized methods of each of these classes. </para> 
	 <para> The base class of Bond is
	 	<ulink url="api/org/openscience/cdk/ElectronContainer.html">ElectronContainer</ulink>
	 	 because a Bond shares
		some properties with an atomic or molecular orbital, most importantly a
		particular number of electrons contained by the entity in question. </para> 
	 <para> Ensembles of Molecules, like those involved in a chemical reaction,
		can be organized in a 
	 	<ulink url="api/org/openscience/cdk/SetOfMolecules.html">SetOfMolecules</ulink>		
		class. </para> 
	 <para> Due to the dedication of the Model/View/Controller paradigm, the
		programmer will find a 
	 	<ulink url="api/org/openscience/cdk/ChemModel.html">ChemModel</ulink>,
		which can store all of the above concepts. It
		is supposed to represent a particular state of the programm at a given point in
		time. A sequence of ChemModels, representing for example different points in
		time in a molecular dynamics simulation of an ensemble molecules, can be stored
		in a ChemSequence. A ChemFile, the highest level concept, in our CDK hierarchy,
		can store all of the above concepts. </para> 
  </section> 
  <section>
	 <title>File I/O Classes</title>
         <para>At this moment the following Input classes are available:
           <itemizedlist>
                <listitem><para>&MDLReader;</para></listitem>
                <listitem><para>&CMLReader;</para></listitem>
                <listitem><para>&XYZReader;</para></listitem>
           </itemizedlist>
           To read a molecule use:
           <example>
             <programlisting>
        ChemObjectReader reader;
        String inFile = "filetoread.xyz";
        if (inFile.endsWith(".xyz")) {
              reader = new XYZReader(new FileReader(inFile));
        } else if (inFile.endsWith(".cml")) {
              reader = new CMLReader(new FileReader(inFile));
        } else {
              reader = new MDLReader(new FileInputStream(inFile));
        }
        ChemFile chemFile = (ChemFile)reader.read((ChemObject)new ChemFile());
             </programlisting>
           </example>
           But a class is planned that does automatic detection of the correct file type.
         </para>
         <para>And these Output classes:
         <itemizedlist>
                <listitem><para><ulink url="api/org/openscience/cdk/io/MDLWriter.html">MDLWriter</ulink></para></listitem>
                <listitem><para><ulink url="api/org/openscience/cdk/io/CMLWriter.html">CMLWriter</ulink></para></listitem>
         </itemizedlist>
         </para>
  </section>
  <section> 
	 <title>The Tools Classes</title> 
	 <para> The tools classes are located in the org.openscience.cdk.tools package. 
	 This package contains everything for which the creation of an own subpackage 
	 could not be justified. Some of them might be moved to their own subpackages later
	 as soon as more classes acting in this particular field have been created. 
	 Currently, the tools package contains:
	 <itemizedlist>
 		<listitem>
			<para>
	 		<ulink url="api/org/openscience/cdk/tools/AtomConstraintsFactory.html">
			AtomConstraintsFactory</ulink>
			, a class generating
			AtomContraints containing informations like maximum
			allowed bond orders for certain chemical elements. Those
			AtomConstraints are used for example in structure
			generators. 
			</para>
		</listitem>
		 <listitem>
			<para>
	 		<ulink url="api/org/openscience/cdk/tools/ConnectivityChecker.html">
			ConnectivityChecker</ulink>
			, a class that checks if an 
			AtomContainer is connected, that is if there is a path
			from each atom to each other atom in the molecule. The
			class also has a method for partitioning an
			AtomContainer into the connected graphs it contains.
			</para>
		</listitem>
		 <listitem>
			<para>
	 		<ulink url="api/org/openscience/cdk/tools/HoseCodeGenerator.html">
			HoseCodeGenerator</ulink>
			generates HOSECodes for atoms in a
			molecule. HOSE stands for Hirarchically Ordered
			Spherical Environment and is a method for describing the
			environment of an atom. It is mostly used in the
			prediciton of carbon nmr. 
			</para>
		</listitem>
		 <listitem>
			<para>
	 		<ulink url="api/org/openscience/cdk/tools/StandardIsotopes.html">
			StandardIsotopes</ulink>
			contains a list of the first 150 known
			isotopes of the table of elements with their exact
			weight and their relative occurrence. It can, for example
			return the
			major isotope for a given element symbol.
			</para>
		</listitem>
		 <listitem>
			<para>
	 		<ulink url="api/org/openscience/cdk/tools/SwissArmyKnife.html">
			SwissArmyKnife</ulink>
			 is an allround tools for methods that
			really didn't fit into anything else. I'm not sure if
			there is any justification for such a class or if it is
			not better to create a new class for each purpose even
			if is only has one method. 
			</para>
		</listitem>
	
	</itemizedlist>
	 </para>
</section>
<section>
<title>Unit Testing the CDK</title>
<para>
A word about testing in the CDK: 
I have already mentioned that I have introduced unit testing with JUnit. 
The class org.openscience.cdk.tests.CDKTests is supposed to run all the tests at once. 
JUnit makes writing an running tests quite easy and it is integrated with Ant, 
so Ant can run automatic unit tests with JUnit. 
So, in contrast to what is written in the CDK readme :-), the CDKTests class is supposed to 
run _all_ the tests and not just the graphical ones. 

Just an example: If you want to test a particular class, say "RingFinder", or another part of the 
CDK, then you write a test class which extends junit.framework.TestCase. 
		
		<example>
		  <title>Extending TestCase</title>
		  <programlisting>

public class RingSearchTest extends TestCase
{
// ...
}
			
		  </programlisting>
		</example>			
		  


TestCase provides a method "setUp()" which is called before any of the tests is run and a number 
of other methods which are less interesting (read the docs at 
<ulink url="http://junit.org">http://junit.org</ulink>). 
One of the small little things that makes your life easier now, is that you can 
make a junit.framework.TestSuite out of your puny little test class by filling the method "suite()" 
with a line of code.
		<example>
		  <title>Making a TestSuite</title>
		  <programlisting>

	public static Test suite() 
	{
		return new TestSuite(RingSearchTest.class);
	}
		  </programlisting>
		</example>			

	
The nicest thing now is that JUnit automatically finds, by introspection, all methods in your 
RingSearchTest class whose method name starts with "test..." and runs them. A test is successfull 
if the assert() method in it returns a boolean "true". In the RingSearchTest, e.g., I run an sssr 
search on a-pinene. I know that the correct size of the Smallest Set of Smallest Rings is "two", 
so my test methods reads:
		<example>
		  <title>The Actual Test</title>
		  <programlisting>

	public void testAlphaPinene()
	{
		ringSet = sssrf.findSSSR(MoleculeFactory.getAlphaPinene());
		assert(ringSet.size() == 2);
	}
		  </programlisting>
		</example>			

Interestingly, the method testAlphaPinene() does not return anything. Somehow they do the evaluation
of the assert method in a different way, also by introspection, supposedly. 

Anyway, it is of course not alway that easy to evaluate the successful completion of a test. 
Especially in cases of graphical output. In the case of the StructureDiagramGenerator I return 
"true" to the assert method if no exception has occured during the layout and all the structures 
are drawn for visual inspection by the human who runs the tests for doing the final visual inspection.

In other cases if might be useful to overwrite the "equals()" method in java.lang.Object in order 
to provide a sophisticated method for testing. If there were a rigorous isomorphism checker in the 
CDK, the equals() method for Molecule could check the ismorphism between this Molecule and a given 
other object which is instanceOf(org.openscience.Molecule).
We could then perform tests for the i/o tasks that relies on this:
		<example>
		  <title>Potential Testing of Successful I/O</title>
		  <programlisting>

	public void testMDLReader()
	{
		Molecule reference = MoleculeFactory.getAlphaPinene();
		Molecule testMol = (new MDLReader(data/a-pinene.mol)).read(new Molecule());
		// assert(reference.equals(testMol));
		// or 
		assert(IsomorphismChecker.areIsomorphic(reference, testMol));
	}
		  </programlisting>
		</example>			

Finally, the CDKTests class is supposed to be a host for all the single TestCases that we write:
		<example>
		  <title>Doing it all together</title>
		  <programlisting>

public class CDKTests {

	static MoleculeListViewer moleculeListViewer = null;

	public static void main (String[] args) 
	{
		moleculeListViewer = new MoleculeListViewer();
		junit.textui.TestRunner.run (suite());
	}

	public static Test suite ( ) 
	{
		TestSuite suite= new TestSuite("All CDK Tests");
		suite.addTest(RingSearchTest.suite());
		suite.addTest(ConnectivityCheckerTest.suite());
		suite.addTest(StructureDiagramGeneratorTest.suite());
		suite.addTest(RandomStructureGeneratorTest.suite());
	    	return suite;
	}
}
		  </programlisting>
		</example>			

It makes a TestSuite and then adds all the single tests and runs them, evaluating the result and 
printing a small summary. 
It is the goal to move all the tests to this framework so that one only has to run the CDKTests class.
</para>
</section>	 

</section>
