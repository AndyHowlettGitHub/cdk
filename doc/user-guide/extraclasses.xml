<chapter>
    <title>Extra Classes</title>
    <section>
      <title>File I/O Classes</title>
      <para>
        At this moment the following Input classes are available:
        <itemizedlist>
          <listitem><para>&MDLReader;</para></listitem>
          <listitem><para>&CMLReader; <ulink url="biblio.html#WILLIGHAGEN2001"/></para></listitem>
          <listitem><para>&XYZReader;</para></listitem>
        </itemizedlist>
        And many more.
      </para>
      <para>
        To read a molecule, the folowing code may be used:
        <example>
          <title>Determining the file format using its name extension</title>
          <programlisting>
ChemObjectReader reader;
String inFile = "filetoread.xyz";
if (inFile.endsWith(".xyz")) {
    reader = new XYZReader(new FileReader(inFile));
} else if (inFile.endsWith(".cml")) {
    reader = new CMLReader(new FileReader(inFile));
} else if (inFile.endsWith(".pdb")) {
    reader = new PDBReader(new FileReader(inFile));
} else {
    reader = new MDLReader(new FileInputStream(inFile));
}
ChemFile chemFile = (ChemFile)reader.read((ChemObject)new ChemFile());
          </programlisting>
        </example>
        It is easier, though, to use a ReaderFactory which will automatically
        detect the file format. The above code then simplifies to:
        <example>
          <title>Getting a ChemObjectReader using the ReaderFactory</title>
          <programlisting>
String inFile = "filetoread.xyz";
FileReader fileReader = new FileReader(inFile);
ChemObjectReader reader = new ReaderFactory().createReader(fileReader);
ChemFile chemFile = (ChemFile)reader.read((ChemObject)new ChemFile());
          </programlisting>
        </example>
      </para>
      <para>And these output classes:
        <itemizedlist>
          <listitem><para>&MDLWriter;</para></listitem>
          <listitem><para>&CMLWriter;</para></listitem>
        </itemizedlist>
      </para>
    </section>

    <section> 
      <title>The Tools Classes</title> 
      <para>
        The tools classes are located in the org.openscience.cdk.tools package. 
        This package contains everything for which the creation of an own subpackage 
        could not be justified. Some of them might be moved to their own subpackages later
        as soon as more classes acting in this particular field have been created. 
        Currently, the tools package contains:
        <itemizedlist>
           <listitem>
             <para>
               &AtomTypeFactory;, a class generating
               AtomContraints containing informations like maximum
               allowed bond orders for certain chemical elements. Those
               AtomConstraints are used for example in structure
               generators. 
             </para>
           </listitem>
           <listitem>
             <para>
               &ConnectivityChecker;, a class that checks if an
               AtomContainer is connected, that is if there is a path
               from each atom to each other atom in the molecule. The
               class also has a method for partitioning an
               AtomContainer into the connected graphs it contains.
             </para>
           </listitem>
           <listitem>
             <para>
               <ulink url="api/org/openscience/cdk/tools/HoseCodeGenerator.html">
               HoseCodeGenerator</ulink>
               generates HOSECodes for atoms in a
               molecule. HOSE stands for Hierarchically Ordered
               Spherical Environment and is a method for describing the
               environment of an atom. It is mostly used in the
               prediciton of carbon NMR. 
             </para>
           </listitem>
           <listitem>
             <para>
               &IsotopeFactory;, produces Isotopes for a given ElementSymbol, based on 
               an XML configuration file in org/openscience/cdk/config
             </para>
           </listitem>
           <listitem>
             <para>
               <ulink url="api/org/openscience/cdk/tools/SwissArmyKnife.html">
               SwissArmyKnife</ulink>
               is an allround tools for methods that
               really didn't fit into anything else. I'm not sure if
               there is any justification for such a class or if it is
               not better to create a new class for each purpose even
               if is only has one method. 
             </para>
           </listitem>
        </itemizedlist>
      </para>
    </section>

    <section> 
        <title>The Structure Generator Classes</title> 
        <para> The Structure Generator classes are located in the org.openscience.cdk.structgen package. 
        They are related to generating constitutional isomers for a given
        molecular formula, often obeying certain contraints. 
        <itemizedlist>
            <listitem>
                <para>
                <ulink url="api/org/openscience/cdk/structgen/RandomGenerator.html">
                RandomGenerator</ulink>
                This structure generator makes small random moves in
                structure space, starting from a given constitutional
                formula, which might be generated using 
                <ulink url="api/org/openscience/cdk/structgen/SingleStructureRandomGenerator.html">
                SingleStructureRandomGenerator</ulink>.
                It does this by randomly choosing four atoms and
                breaking old and forming new bonds according to rules
                defined in <ulink url="biblio.html#FAU96"/>.
                </para>
            </listitem>
            <listitem>
                <para>
                <ulink url="api/org/openscience/cdk/structgen/SingleStructureRandomGenerator.html">
                SingleStructureRandomGenerator</ulink>
                Randomly generates a single, connected, correctly bonded structure for 
                a given molecular formula
                To see it working run the graphical 
                test org.openscience.cdk.test.SingleStructureRandomGeneratorTest
                and add more structures to the panel using the "More" button. 
                In order to use this class, use MFAnalyser to get an AtomContainer from 
                a molecular formula string.
                Assign hydrogen counts to each heavy atom. The hydrogens should not be
                in the atom pool but should be assigned implicitly to the heavy atoms in 
                order to reduce computational cost.
                Assign this AtomContainer to the  
                SingleStructureRandomGenerator and retrieve a randomly generated, but correctly bonded
                structure by using the generate() method. You can then repeatedly call
                the generate() method in order to retrieve further structures. 
                </para>
            </listitem>		
        </itemizedlist>
        </para>
    </section>

    <title>Introduction from the handling of orbitals</title>
    <section>
        <title>Basics</title>
        <para>
        A orbtial were handled through a vector and a basis set. The
        elements were the coefficients for the basis set. A example
        for a basis set are the gauss functions
        </para>
        <para>
        basis_i(x,y,z) = C_i * (x_i - x)^nx_i *  (y_i - y)^ny_i * (z_i - z)^nz_i *
        exp(-alpha * (x_i - x)^2 * (y_i - y)^2 * (z_i - z)^2)
        r_i = [x_i , y_i , z_i]
        </para>
        <para>
        The class GaussiansBasis will used to calculates the basis. For 
        example, we want construct a px, py and a pz-Orbital. The coefficient
        for the basis are nx=[1,0,0], ny=[0,1,0], nz=[0,0,1]. Was the position
        of these orbitals at the center of an atom, were x_i,y_i,z_i the
        coordinates of the atom.
        </para>
        <programlisting>
        int[] nx = new int[3]{1,0,0};
        int[] ny = new int[3]{0,1,0};
        int[] ny = new int[3]{0,0,1};
        double[] alpha = new double[3]{1d,1d,1d};
        Vector[] r = new Vector[3]{new Vector(atom.getPoint3D())
                                    new Vector(atom.getPoint3D())
                                    new Vector(atom.getPoint3D())};
        Atom[] atoms = new Atom[]{atom};

        GaussiansBasis basis = new GaussiansBasis(nx,ny,nz,alpha,r,atoms);
        </programlisting>
        <para>
        For the declaration of the orbials we need the coefficients for the
        basis. The px Orbital got the vector O_1=[1,0,0], the py Orbital O_2=[0,1,0]
        and the pz orbital O_3=[0,0,1]
        </para>
        <para>
        f_i(x,y,z) = O_i * basis_i
        </para>
        <para>
        The class orbitals used to store the coefficients. The class stores the
        coefficients in a matrix. Each column are a orbital.
        </para>
        <programlisting>
        Matrix coeff = new Matrix(new double[][]
            {
            {1d, 0d, 0d},
            {0d, 1d, 0d},
            {0d, 0d, 1d}
            });
        Orbitals orbitals = new Orbitals(basis, coeff);
        </programlisting>
        <para>
        To render the orbitals we could use the AcceleratedRenderer3D
        </para>
        <programlisting>
        int currentorbital = 0;
        AcceleratedRenderer3DModel model = new AcceleratedRenderer3DModel(orbitals, currentorbital);
        AcceleratedRenderer3D renderer = new AcceleratedRenderer3D(model);

        frame.add(renderer, BorderLayout.CENTER);
        </programlisting>
    </section>

</chapter>
