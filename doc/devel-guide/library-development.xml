  <chapter id="sect:goal">
      <title>The Goal</title>
      <para>
        The goal of the CDK is to be a library of java classes to support
        java software to solve typical chemical computational and informational
        problems.
      </para>
    </chapter>

    <chapter id="sect:classcategories">
      <title>CDK Modules</title>
      <para>
        All CDK classes are categorized into classes. Currently, these classes
        are defined: cdk-data, cdk-core, cdk-standard, cdk-io, cdk-render,
        cdk-libio, cdk-extra, cdk-experimental, cdk-orphaned, and several more.
      </para>
      <para>
        The data module contains the data classes of the CDK library. Nothing
        more, nothing less.
        The core module contains several of the more central algorithms in CDK,
        i.e. algorithms that are used by many other algorithms. Both these classes
        are now stable.
      </para>
      <para>
        Many of these modules have dependencies on other modules. An overview
        is available on the CDK website: <ulink url="http://cheminfo.informatics.indiana.edu/~rguha/code/java/nightly/cdkdep.ps">module
        dependencies</ulink>.
      </para>
      <section>
        <title>Library IO modules</title>
        <para>
          CDK contains three modules that allow interaction with other libraries:
          libio-cml for CMLDOM, libio-joelib for 
          <ulink url="http://joelib.sf.net/">JOELib</ulink>, and io-jmol for the 
          IO classes in <ulink url="http://www.jmol.org/">Jmol</ulink>.
        </para>
      </section>
      <section>
        <title>Special modules</title>
        <para>
          There are a few special modules, which are normally not used by users.
          The most obvious module is the test module. But others are: the experimental
          module, which contains code not yet trusted or finished enough; and the
          orphaned module with classes which can no longer be supported by the
          CDK developers.
        </para>
      </section>
    </chapter>

  <chapter id="sect:compiling">
    <title>Compiling the CDK source</title>

    <para>
      Compiling and jar-ing the software is done with <ulink
      url="http://jakarta.apache.org/ant/">Jakarta's Ant</ulink>.
    </para>

    <para>
      CDK can be compiled with and without support for a number of libraries:
      Java3D, JOELib and Xerces.
      The availability of those libraries is normally autodetected. An overview
      is given with the command:
      <programlisting>
cdk/$ ant info
      </programlisting>
    </para>

    <para>
      CDK can be compiled into small module jars with:
      <programlisting>
cdk/$ ant clean dist-all
      </programlisting>
      Or, alternatively, into one big jar with:
      <programlisting>
cdk/$ ant clean dist-large
      </programlisting>
    </para>
    
    <section>
      <title>Debugging and Optimization</title>
      <para>
        It is useful to compile CDK with debugging information while
        writing and testing new code, but when making a release the code
        must be optimized for speed and size: debugging information must
        be turned off then, and optimization turned on.
        The build.xml file by default compiles with debugging options, but
        this can be overwritten. The next example shows you how to compile
        CDK for release:
        <programlisting>
cdk/$ ant -Ddebug=off -Doptimization=on -Ddeprecation=off dist-all
        </programlisting>
      </para>
    </section>
    
    <section>
      <title>Patches</title>
      <para>
        Sometimes it may be required to apply patches to the source code
        before it is compiled. For example, the CDK source code needs to be
        patches before Jmol can use it in an applet. Reasons can be that CDK
        want to use post Java 1.1 methods and classes, or that it uses
        some algorithm that violates applet security model.
      </para>
      <para>
        Patches are kept in CVS in the <filename class="directory">cdk/src/patches</filename>
        and generated with a diff utility:
        <programlisting>
cdk/$ diff -u path/to/OriginalFile.java path/to/PatchedFile.java
        </programlisting>
        E.g. for LoggingTool.java the command looks like:
        <programlisting>
cdk/$ diff -u src/org/openscience/cdk/tools/LoggingTool.java src/org/openscience/cdk/tools/LoggingTool.java.withoutLog4J
        </programlisting>
        The -u option indicates that the ouput should be unified diff format,
        which is much more readable than the default format.
        The patch can be stored in the patch directory in the same step using:
        <programlisting>
cdk/$ diff -u path/to/OriginalFile.java path/to/PatchedFile.java > src/patches/somePatch.txt
        </programlisting>
      </para>
      <para>
        Patches can be automatically applied by Ant using the &lt;patch>
        task, as is done in the current build.xml for CDK. The task requieres
        a program <filename>patch.exe</filename> of <filename>patch</filename>
        to be installed, which is normally installed by default on Unix systems.
        Windows users are referred to Cygwin, which is a Unix shell that can be
        run on a Windows system. Alternatively, you could use "cvs diff -u", but
        this is not recommended.
      </para>
    </section>
  </chapter>

  <chapter id="sect:testing">
    <title>Testing CDK classes</title>

    <section>
      <title>JUnit testing</title>
      <para>
        After you compiled the code, you can do <command>ant test</command>
        to run the test suite of non-interactive, automated
        tests. You will get output with a part something like:
        <programlisting>
test:
    [junit] Running org.openscience.cdk.test.CDKTests
    [junit] Tests run: 21, Failures: 5, Errors: 0, Time elapsed: 9.63 sec
    [junit] TEST org.openscience.cdk.test.CDKTests FAILED
        </programlisting>
        These tests results in some serious problems.
      </para>

      <para>
        Individual tests can be done with the run-test target. The command
        <command>ant -Dtestclass=ringsearch.RingSearchTest run-test</command>,
        for example, will run the test RingSearchTest. It will first run it
        within the JUnit environment giving output as given above. Detailed
        information about the run will, for the given example, be saved in 
        cdk/reports/results.ringsearch.RingSearchTest.txt. In a second step,
        this target will atempt to run the test using it's main() method,
        but this will fail when no such method is provided.
      </para>
      
      <para>
        The actual tests are done by
        <ulink url="http://www.junit.org/">JUnit</ulink> which you must have
        installed. JDK 1.4 requires version 3.7, but 3.6 is good for older
        Java versions.
      </para>

    </section>
    
    <section>
      <title>Interactive tests</title>
      <para>
        There are also run interactive tests, like the Controller2DTest.
        In order to try them, you can edit the "run"
        target in the build.xml file to look like this:
        <programlisting><![CDATA[
          <target name="run" depends="dist">
                <java classname="org.openscience.cdk.test.ControllerTest" fork="yes">
                        <arg value=""/>
                        <classpath>
                                <pathelement location="${dist}/jar/cdk.jar"/>
                                <pathelement path="${java.class.path}"/>
                                <pathelement location="."/>
                                <fileset dir="jar">
                                <include name="*.jar"/>
                                </fileset>
                        </classpath>
                </java>
          </target>
]]></programlisting>
        Then, a <command>ant run</command> should give you a window where you
        can add bonds to a given structure.
      </para>
    </section>

    <section>
    <title>Writing Unit Testing</title>
    <para>
    A word about testing in the CDK: 
    I have already mentioned that I have introduced unit testing with JUnit. 
    The class org.openscience.cdk.tests.CDKTests is supposed to run all the tests at once. 
    JUnit makes writing an running tests quite easy and it is integrated with Ant, 
    so Ant can run automatic unit tests with JUnit. 
    So, in contrast to what is written in the CDK readme :-), the CDKTests class is supposed to 
    run _all_ the tests and not just the graphical ones. 

    Just an example: If you want to test a particular class, say "RingFinder", or another part of the 
    CDK, then you write a test class which extends junit.framework.TestCase. 

            <example>
            <title>Extending TestCase</title>
            <programlisting>

    public class RingSearchTest extends TestCase
    {
    // ...
    }

            </programlisting>
            </example>



    TestCase provides a method "setUp()" which is called before any of the tests is run and a number 
    of other methods which are less interesting (read the docs at 
    <ulink url="http://junit.org">http://junit.org</ulink>). 
    One of the small little things that makes your life easier now, is that you can 
    make a junit.framework.TestSuite out of your puny little test class by filling the method "suite()" 
    with a line of code.
            <example>
            <title>Making a TestSuite</title>
            <programlisting>

        public static Test suite() 
        {
            return new TestSuite(RingSearchTest.class);
        }
            </programlisting>
            </example>


    The nicest thing now is that JUnit automatically finds, by introspection, all methods in your 
    RingSearchTest class whose method name starts with "test..." and runs them. A test is successfull 
    if the assert() method in it returns a boolean "true". In the RingSearchTest, e.g., I run an sssr 
    search on a-pinene. I know that the correct size of the Smallest Set of Smallest Rings is "two", 
    so my test methods reads:
            <example>
            <title>The Actual Test</title>
            <programlisting>

        public void testAlphaPinene()
        {
            ringSet = sssrf.findSSSR(MoleculeFactory.getAlphaPinene());
            assert(ringSet.size() == 2);
        }
            </programlisting>
            </example>

    Interestingly, the method testAlphaPinene() does not return anything. Somehow they do the evaluation
    of the assert method in a different way, also by introspection, supposedly. 

    Anyway, it is of course not alway that easy to evaluate the successful completion of a test. 
    Especially in cases of graphical output. In the case of the StructureDiagramGenerator I return 
    "true" to the assert method if no exception has occured during the layout and all the structures 
    are drawn for visual inspection by the human who runs the tests for doing the final visual inspection.

    In other cases if might be useful to overwrite the "equals()" method in java.lang.Object in order 
    to provide a sophisticated method for testing. If there were a rigorous isomorphism checker in the 
    CDK, the equals() method for Molecule could check the ismorphism between this Molecule and a given 
    other object which is instanceOf(org.openscience.Molecule).
    We could then perform tests for the i/o tasks that relies on this:
            <example>
            <title>Potential Testing of Successful I/O</title>
            <programlisting>

        public void testMDLReader()
        {
            Molecule reference = MoleculeFactory.getAlphaPinene();
            Molecule testMol = (new MDLReader(data/a-pinene.mol)).read(new Molecule());
            // assert(reference.equals(testMol));
            // or 
            assert(IsomorphismChecker.areIsomorphic(reference, testMol));
        }
            </programlisting>
            </example>

    Finally, the CDKTests class is supposed to be a host for all the single TestCases that we write:
            <example>
            <title>Doing it all together</title>
            <programlisting>

    public class CDKTests {

        static MoleculeListViewer moleculeListViewer = null;

        public static void main (String[] args) 
        {
            moleculeListViewer = new MoleculeListViewer();
            junit.textui.TestRunner.run (suite());
        }

        public static Test suite ( ) 
        {
            TestSuite suite= new TestSuite("All CDK Tests");
            suite.addTest(RingSearchTest.suite());
            suite.addTest(ConnectivityCheckerTest.suite());
            suite.addTest(StructureDiagramGeneratorTest.suite());
            suite.addTest(RandomStructureGeneratorTest.suite());
                return suite;
        }
    }
            </programlisting>
            </example>

    It makes a TestSuite and then adds all the single tests and runs them, evaluating the result and 
    printing a small summary. 
    It is the goal to move all the tests to this framework so that one only has to run the CDKTests class.
    </para>
    </section>
    
    
  </chapter>
  
  <chapter id="sect:profiling">
    <title>Debugging memory usage and performance</title>
    <para>
      Once functionality is working, and remaining bugs are removed, it is time to
      optimize the source code, in terms of memory usage and performance. A profiling
      tool is need for this, e.g. 
      <ulink url="http://www.khelekore.org/jmp/">jmp</ulink>. With this program you can
      very easily profile your classes by typing something like:
      <command>java -Xrunjmp org.openscience.cdk.test.SomeTest</command>.
    </para>
    <para>
      Jmp can be run in a graphical mode, which can only be used if the program does not
      terminate, e.g. like cdk-fileconvert. Otherwise the <command>nogui</command>
      may be used (as in <command>java -Xrunjmp:nogui</command> which will create
      a file containing the profiling information.
    </para>
    <para>
      It becomes even better if you get the hang of filters; try for example
      <command>java -Xrunjmp:nogui,filter=org.openscience.cdk</command>.
    </para>
  </chapter>
  
  <chapter id="sect:bugs">
    <title>Dealing with bugs</title>
    <para>
      Bugs are, unfortunately, something inherent to source code. And, CDK is not bugless.
      They can be reported on the
      <ulink url="http://sourceforge.net/tracker/?group_id=20024&amp;atid=120024">SF website</ulink>.
      When a user files a bug, it can be accepted by a developer, by reproducing the bug
      <emphasis>and</emphasis>, if possible, making a JUnit test that reproduces the bug.
      The latter is important to ensure that the bug will never ever be created again.
    </para>
  </chapter>

