<part id="part:cdk-library">
  <title>The CDK Library</title>

  <chapter id="sect:goal">
      <title>The Goal</title>
      <para>
        The goal of the CDK is to be a library of java classes to support
        java software to solve typical chemical computational and informational
        problems.
      </para>
    </chapter>

    <chapter id="sect:classcategories">
      <title>CDK Modules</title>
      <para>
        All CDK classes are categorized into classes. Currently, these classes
        are defined: cdk-core, cdk-standard, cdk-io, cdk-render,
        cdk-libio and cdk-extra.
      </para>
      <section>
        <title>Core classes</title>
        <para>
          In the cdk-core module the core classes represent chemical entities, like 
          bonds, atoms, molecules, and
          more abstract entities, like connectivity tables, used for in common
          computational and information chemistry.
        </para>
      </section>
      <section>
        <title>Standard classes</title>
        <para>
          The standard classes found in the cdk-standard module are those classes that
          do not store chemical data, but that are used by two or more of the modules
          below, and that are considered basic.
        </para>
      </section>
      <section>
        <title>IO classes</title>
        <para>
          The cdk-io module contains classes for file, internet and database input and
          output.
        </para>
      </section>
      <section>
        <title>Rendering classes</title>
        <para>
          The cdk-render module provides classes for displaying 2D and 3D chemical
          information, and classes that provide ways to have users interact with these
          graphical representations.
        </para>
      </section>
      <section>
        <title>LibIO classes</title>
        <para>
          These classes interface to other (Java) libraries, like JOELib and CMLDOM.
        </para>
      </section>
      <section>
        <title>Extra classes</title>
        <para>
          These are classes that do not belong to either of the other two categories.
        </para>
      </section>

    </chapter>

  <chapter id="sect:compiling">
    <title>Compiling the CDK source</title>

    <para>
      Compiling and jar-ing the software is done with <ulink
      url="http://jakarta.apache.org/ant/">Jakarta's Ant</ulink>.
    </para>

    <para>
      CDK can be compiled with and without support for Java3D.
      How to compile these, is explained in the next two sections.
    </para>

    <section>
      <title>Compiling without Java3D installed</title>
      <para>
        If not Java3D is installed or available for your platform,
        you can compile CDK with:
        <programlisting>
cdk/$ ant
        </programlisting>
      </para>
    </section>

    <section>
      <title>Compiling with Java3D installed</title>
      <para>
        If Java3D is installed or available for your platform,
        you can compile CDK with:
        <programlisting>
cdk/$ ant -Dpathtojava3d=/some/path compile-with-java3d
        </programlisting>
        The parameter pathtojava3d can be used to tell Ant where
        your Java3D installation (read: jar files) can be found.
      </para>
    </section>

    <section>
      <title>Debugging and Optimization</title>
      <para>
        It is useful to compile CDK with debugging information while
        writing and testing new code, but when making a release the code
        must be optimized for speed and size: debugging information must
        be turned off then, and optimization turned on.
        The build.xml file by default compiles with debugging options, but
        this can be overwritten. The next example shows you how to compile
        CDK for release:
        <programlisting>
cdk/$ ant -Ddebug=off -Doptimization=on -Ddeprecation=off dist-all
        </programlisting>
      </para>
    </section>
    
  </chapter>

  <chapter id="sect:testing">
    <title>Testing CDK classes</title>

    <section>
      <title>JUnit testing</title>
      <para>
        After you compiled the code, you can do <command>ant test</command>
        to run the test suite of non-interactive, automated
        tests. You will get output with a part something like:
        <programlisting>
test:
    [junit] Running org.openscience.cdk.test.CDKTests
    [junit] Tests run: 21, Failures: 5, Errors: 0, Time elapsed: 9.63 sec
    [junit] TEST org.openscience.cdk.test.CDKTests FAILED
        </programlisting>
        These tests results in some serious problems.
      </para>

      <para>
        The actual tests are done by
        <ulink url="http://www.junit.org/">JUnit</ulink> which you must have
        installed. JDK 1.4 requires version 3.7, but 3.6 is good for other
        Java versions.
      </para>

      <para>
        An alternative is to install the cdk-test package.
        You can then do tests with
        <programlisting>
$ cdk-test org.openscience.cdk.test.CDKTests
        </programlisting>
      </para>

      <para>
        There are currently two major test suites:
        <itemizedlist>
          <listitem><para>org.openscience.cdk.test.CDKTests</para></listitem>
          <listitem><para>org.openscience.cdk.test.io.cml.CMLIOTests</para></listitem>
        </itemizedlist>
      </para>
    </section>
    
    <section>
      <title>Interactive tests</title>
      <para>
        There are also run interactive tests, like the Controller2DTest.
        In order to try them, you can edit the "run"
        target in the build.xml file to look like this:
        <programlisting><![CDATA[
          <target name="run" depends="dist">
                <java classname="org.openscience.cdk.test.ControllerTest" fork="yes">
                        <arg value=""/>
                        <classpath>
                                <pathelement location="${dist}/jar/cdk.jar"/>
                                <pathelement path="${java.class.path}"/>
                                <pathelement location="."/>
                                <fileset dir="jar">
                                <include name="*.jar"/>
                                </fileset>
                        </classpath>
                </java>
          </target>
]]></programlisting>
        Then, a <command>ant run</command> should give you a window where you
        can add bonds to a given structure.
      </para>
    </section>

    <section>
    <title>Writing Unit Testing</title>
    <para>
    A word about testing in the CDK: 
    I have already mentioned that I have introduced unit testing with JUnit. 
    The class org.openscience.cdk.tests.CDKTests is supposed to run all the tests at once. 
    JUnit makes writing an running tests quite easy and it is integrated with Ant, 
    so Ant can run automatic unit tests with JUnit. 
    So, in contrast to what is written in the CDK readme :-), the CDKTests class is supposed to 
    run _all_ the tests and not just the graphical ones. 

    Just an example: If you want to test a particular class, say "RingFinder", or another part of the 
    CDK, then you write a test class which extends junit.framework.TestCase. 

            <example>
            <title>Extending TestCase</title>
            <programlisting>

    public class RingSearchTest extends TestCase
    {
    // ...
    }

            </programlisting>
            </example>



    TestCase provides a method "setUp()" which is called before any of the tests is run and a number 
    of other methods which are less interesting (read the docs at 
    <ulink url="http://junit.org">http://junit.org</ulink>). 
    One of the small little things that makes your life easier now, is that you can 
    make a junit.framework.TestSuite out of your puny little test class by filling the method "suite()" 
    with a line of code.
            <example>
            <title>Making a TestSuite</title>
            <programlisting>

        public static Test suite() 
        {
            return new TestSuite(RingSearchTest.class);
        }
            </programlisting>
            </example>			


    The nicest thing now is that JUnit automatically finds, by introspection, all methods in your 
    RingSearchTest class whose method name starts with "test..." and runs them. A test is successfull 
    if the assert() method in it returns a boolean "true". In the RingSearchTest, e.g., I run an sssr 
    search on a-pinene. I know that the correct size of the Smallest Set of Smallest Rings is "two", 
    so my test methods reads:
            <example>
            <title>The Actual Test</title>
            <programlisting>

        public void testAlphaPinene()
        {
            ringSet = sssrf.findSSSR(MoleculeFactory.getAlphaPinene());
            assert(ringSet.size() == 2);
        }
            </programlisting>
            </example>			

    Interestingly, the method testAlphaPinene() does not return anything. Somehow they do the evaluation
    of the assert method in a different way, also by introspection, supposedly. 

    Anyway, it is of course not alway that easy to evaluate the successful completion of a test. 
    Especially in cases of graphical output. In the case of the StructureDiagramGenerator I return 
    "true" to the assert method if no exception has occured during the layout and all the structures 
    are drawn for visual inspection by the human who runs the tests for doing the final visual inspection.

    In other cases if might be useful to overwrite the "equals()" method in java.lang.Object in order 
    to provide a sophisticated method for testing. If there were a rigorous isomorphism checker in the 
    CDK, the equals() method for Molecule could check the ismorphism between this Molecule and a given 
    other object which is instanceOf(org.openscience.Molecule).
    We could then perform tests for the i/o tasks that relies on this:
            <example>
            <title>Potential Testing of Successful I/O</title>
            <programlisting>

        public void testMDLReader()
        {
            Molecule reference = MoleculeFactory.getAlphaPinene();
            Molecule testMol = (new MDLReader(data/a-pinene.mol)).read(new Molecule());
            // assert(reference.equals(testMol));
            // or 
            assert(IsomorphismChecker.areIsomorphic(reference, testMol));
        }
            </programlisting>
            </example>			

    Finally, the CDKTests class is supposed to be a host for all the single TestCases that we write:
            <example>
            <title>Doing it all together</title>
            <programlisting>

    public class CDKTests {

        static MoleculeListViewer moleculeListViewer = null;

        public static void main (String[] args) 
        {
            moleculeListViewer = new MoleculeListViewer();
            junit.textui.TestRunner.run (suite());
        }

        public static Test suite ( ) 
        {
            TestSuite suite= new TestSuite("All CDK Tests");
            suite.addTest(RingSearchTest.suite());
            suite.addTest(ConnectivityCheckerTest.suite());
            suite.addTest(StructureDiagramGeneratorTest.suite());
            suite.addTest(RandomStructureGeneratorTest.suite());
                return suite;
        }
    }
            </programlisting>
            </example>			

    It makes a TestSuite and then adds all the single tests and runs them, evaluating the result and 
    printing a small summary. 
    It is the goal to move all the tests to this framework so that one only has to run the CDKTests class.
    </para>
    </section>
    
    
  </chapter>
  
  <chapter id="sect:releasing">
    <title>Releasing a CDK version</title>
    <para>
      Making a new CDK release involves much work. It is not just enough to build a set
      of CDK module jars from CVS and put that in a zip or tar file. Some quality has to
      be assured. This chapter will give an overview of the things that need to be done
      and checked before a release can be made.
    </para>
    <para>
      Basically, the list below covers the process. In the rest of this chapter these
      points are further described.
      <orderedlist>
        <listitem><para>Make CDK compiles from scratch</para></listitem>
        <listitem><para>Make the JUnit tests succeed</para></listitem>
        <listitem><para>Make the Javadoc generate without errors and warnings</para></listitem>
        <listitem><para>Report bugs that cannot be fixed easily on SourceForge</para></listitem>
        <listitem><para>Make the Changelog up to date</para></listitem>
        <listitem><para>Make the other documentation up to date</para></listitem>
        <listitem><para>Make the tar.gz package</para></listitem>
        <listitem><para>Determine the status of each module (stable, unstable)</para></listitem>
        <listitem><para>Write the release notes</para></listitem>
        <listitem><para>Publish the packages on SourceForge</para></listitem>
        <listitem><para>Email the release notes to the mailling lists</para></listitem>
        <listitem><para>Update the website and add release notes to it</para></listitem>
        <listitem><para>Tag CVS for this release</para></listitem>
      </orderedlist>
    </para>
    <para>
      At this moment Egon Willighagen is CDK's release manager and takes care of all of this.
    </para>
  </chapter>  
  
</part>
